<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust on Sony PlayStation Vita Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Development guide</li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="build/index.html"><strong aria-hidden="true">2.</strong> Building</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="build/optimizations.html"><strong aria-hidden="true">2.1.</strong> Optimizations</a></li><li class="chapter-item expanded "><a href="build/linking.html"><strong aria-hidden="true">2.2.</strong> Linking native dependencies</a></li><li class="chapter-item expanded "><a href="build/ci.html"><strong aria-hidden="true">2.3.</strong> Building in a CI pipeline</a></li></ol></li><li class="chapter-item expanded "><a href="dev/index.html"><strong aria-hidden="true">3.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dev/mem.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="dev/net.html"><strong aria-hidden="true">3.2.</strong> Network</a></li><li class="chapter-item expanded "><a href="dev/graphics.html"><strong aria-hidden="true">3.3.</strong> Graphics</a></li></ol></li><li class="chapter-item expanded "><a href="running.html"><strong aria-hidden="true">4.</strong> Running</a></li><li class="chapter-item expanded "><a href="unsupported_features.html"><strong aria-hidden="true">5.</strong> Unsupported features</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust on Sony PlayStation Vita Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Rust on Sony PlayStation Vita Book: An introductory book about using the Rust Programming Language on Sony PlayStation Vita.</p>
<p>Here you can find guidelines on how to start making applications for Sony PlayStation Vita in Rust with std using open source <a href="https://vitasdk.org/">Vita SDK</a> homebrew toolchain.</p>
<h2 id="considerations"><a class="header" href="#considerations">Considerations</a></h2>
<p>Though it's technically possible to run nostd applications written in pure Rust on Vita (without any additional toolchains), this book focuses on running applications with std. Rust std for Vita target is implemented via <a href="https://github.com/vitasdk/newlib">newlib</a>, and relies on the <a href="https://vitasdk.org/">Vita SDK</a> toolchain - patched <code>gcc</code> compiler, patched <code>binutils</code>, as well as a number of CLI tools that allow converting an armv7 elf into an artifact runnable on Vita. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Vita is a <a href="https://doc.rust-lang.org/nightly/rustc/platform-support/armv7-sony-vita-newlibeabihf.html">tier 3 target</a> with std available when compiled from source by the user.</p>
<p>To build Rust application for Sony PlayStation Vita you need the following installed:</p>
<ul>
<li>Rust nightly (since building std is an unstable feature)</li>
<li><a href="https://vitasdk.org/">Vita SDK</a> (for std and tools to build a runnable artifact)</li>
<li><a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a> (to simplify the process of building runnable artifacts)</li>
</ul>
<p><a href="https://github.com/vita-rust/cargo-vita">Cargo-vita</a> uses <a href="https://vitasdk.org/">Vita SDK</a> toolchain for compilation, and requires you to set <code>VITASDK</code> environment variable to your <a href="https://vitasdk.org/">Vita SDK</a> installation path.</p>
<p>Also, you will have to add the following section to your projects <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.vita]
# A unique identifier for your project. 9 chars, alphanumeric.
title_id = &quot;RUSTAPP01&quot;
# A title that will be shown on a bubble. Optional, will take the crate name as the default
title_name = &quot;My application&quot;
# Optional. A path to static files relative to the project.
assets = &quot;static&quot;
# Optional, this is the default
build_std = &quot;std,panic_unwind&quot;
# Optional, this is the default
vita_strip_flags = [&quot;-g&quot;]
# Optional, this is the default
vita_make_fself_flags = [&quot;-s&quot;]
# Optional, this is the default
vita_mksfoex_flags = [&quot;-d&quot;, &quot;ATTRIBUTE2=12&quot;]
</code></pre>
<h2 id="optional-tools"><a class="header" href="#optional-tools">Optional tools</a></h2>
<p>Optionally you may want to have a number of tools installed to simplify the development and debugging process.</p>
<ul>
<li><a href="https://github.com/devnoname120/vitacompanion">vitacompanion</a> for <code>--upload</code>, <code>--update</code> and <code>--run</code> flags of <a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a></li>
<li><a href="https://github.com/CelesteBlue-dev/PSVita-RE-tools/tree/master/PrincessLog/build">PrincessLog</a> is required for <code>cargo vita logs</code></li>
<li><a href="https://github.com/xyzz/vita-parse-core">vita-parse-core</a> for <code>cargo vita coredump parse</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building"><a class="header" href="#building">Building</a></h1>
<p>From here on you can write your code the same way you would write it for any other platform!</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::time::Duration;

pub fn main() {
    std::thread::sleep(Duration::from_secs(10))
}</code></pre></pre>
<p>The usual final output for the Vita target is a <code>vpk</code> file.
A <code>vpk</code> file is essentially a zip archive with your applications binary, resources and a manifest for Vita bubbles.</p>
<p>A process of building a <code>vpk</code> involves a number of steps:</p>
<ol>
<li>Building a usual eld with Rust std. The standard library can be compiled in rust using an unstable flag:
<pre><code class="language-sh">cargo build -Z build-std=std,panic_abort --target=armv7-sony-vita-newlibeabihf --release
</code></pre>
</li>
<li>(Optional) Stripping unnecessary symbols from the binary to shrink it's size:
<pre><code class="language-sh">arm-vita-eabi-strip -g your-binary.elf
</code></pre>
</li>
<li>Buildin a <code>velf</code> from your <code>elf</code>. This can be done using a tool from <a href="https://vitasdk.org/">Vita SDK</a> toolchain:
<pre><code class="language-sh">vita-elf-create your-binary.elf your-binary.velf
</code></pre>
</li>
<li>Create an <code>eboot.bin</code> from the <code>velf</code>. This can be done using a tool from <a href="https://vitasdk.org/">Vita SDK</a> toolchain:
<pre><code class="language-sh">vita-make-fself -s your-binary.velf eboot.bin
</code></pre>
</li>
<li>Pack the <code>eboot.bin</code>, assets and a manifest into a <code>vpk</code> file. This can be done using <code>vita-mksfoex</code> and <code>vita-pack-vpk</code> tools from <a href="https://vitasdk.org/">Vita SDK</a> toolchain.</li>
</ol>
<p>All these steps can be by using <code>cargo-vita</code>:</p>
<pre><code class="language-sh"># Build a elf
cargo vita build elf {{all arguments here are passed directly to cargo build}}
# Build a velf. Implicitly executes `cargo vita build elf`
cargo vita build velf {{all arguments here are passed directly to cargo build}}
# Build a eboot.bin. Implicitly executes `cargo vita build velf`
cargo vita build eboot {{all arguments here are passed directly to cargo build}}
# Build a eboot.bin. Implicitly executes `cargo vita build eboot`
cargo vita build vpk {{all arguments here are passed directly to cargo build}}
</code></pre>
<p>Just like the usual <code>cargo build</code> this tool will also build all workspace crates, unless a specific project is specified as a CLI flag.
Here are some more examples:</p>
<pre><code class="language-sh"># Build all workspace crates with --release flag, and upload the resulting vpk files to ux0:/download/
cargo build vpk --upload --release
# Build std tests from examples
cargo vita build vpk --release --package vita-std-tests --tests
# Build a eboot for an already installed vpk, upload it to Vita, and run the application
cargo vita build eboot --update --run --release --package vita-example-http
# Build test suite named socket in a project that does not have [package.metadata.vita] section in Cargo.toml
cargo vita build --default-title-id=RUST00001 eboot --update --run --test socket --features all
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h1>
<p>To reduce the size of the resulting artifacts, prefer using <code>release</code> builds, and add the following to your root <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
lto = true
opt-level = 3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-native-dependencies"><a class="header" href="#linking-native-dependencies">Linking native dependencies</a></h1>
<p>Currently <a href="https://github.com/vitasdk/newlib">newlib</a> on Vita does not support dynamic linking.
Any native dependency you may want to use must be statically linked. This can be done in a number of ways.</p>
<p>You can declare them in your code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;mathneon&quot;, kind = &quot;static&quot;)]
extern &quot;C&quot; {}
<span class="boring">}</span></code></pre></pre>
<p>Or you can define them in <code>build.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
    println!(&quot;cargo:rustc-link-lib=mathneon&quot;);
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-in-a-ci-pipeline"><a class="header" href="#building-in-a-ci-pipeline">Building in a CI pipeline</a></h1>
<p>If you want to build your <code>vpk</code> in a CI pipeline, you can use a <code>ghcr.io/vita-rust/vitasdk-rs</code> <a href="https://github.com/vita-rust/docker">docker image</a>.
This image is based on alpine, and contains <a href="https://vitasdk.org/">Vita SDK</a>, Rust nightly and <a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a>.</p>
<p>The image is rebuilt automatically by a Github Actions pipeline with the latest dependencies on a weekly basis.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<p>To support platform dependent aspects of your application, such as input, audio and graphics, you will have to use User and Kernel functions exported by Vita modules.
These functions become available when linking against the appropriate stubs provided by <a href="https://vitasdk.org/">Vita SDK</a>. The descriptions of the exported data structures and functions can be found in <a href="https://docs.vitasdk.org/">Vita SDK docs</a>.</p>
<p>To use them in Rust, you must use <a href="https://crates.io/crates/vitasdk-sys">vitasdk-sys</a>. This crate uses <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a> to generate Rust bindings from C headers. The exported functions are grouped by their stubs and become available after enabling the corresponding feature in <a href="https://crates.io/crates/vitasdk-sys">vitasdk-sys</a>. The documentation can be found in <a href="https://docs.rs/vitasdk-sys/0.3.2/vitasdk_sys/">vitasdk-sys docs</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>Sony PlayStation Vita <a href="https://wiki.henkaku.xyz/vita/Kermit">SoC</a> has two memory dies:</p>
<ul>
<li>512 MiB of LPDDR2 DRAM (which in allocations is further separated into MAIN, CDLG and PHYCONT)</li>
<li>128 MiB of CDRAM, usually used as video memory</li>
</ul>
<h2 id="budget"><a class="header" href="#budget">Budget</a></h2>
<p>Not all of this memory would usually be available for your application though (see more about the <a href="https://wiki.henkaku.xyz/vita/Memory_budget">Memory Budget</a>).
By default your application has access only to 256 MiB of MAIN memory, 112 MiB of CDRAM, 26 MiB of PHYCONT and around 8 MiB of CDLG.</p>
<p>It is possible to increase the default MAIN memory budget to 365 MiB by passing <code>&quot;-d ATTRIBUTE2=12</code> to <code>vita-mksfoex</code> tool of <a href="https://vitasdk.org/">Vita SDK</a> when building a <code>vpk</code>.
If you are using <a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a> tool to build your project, this flag is set by default, and can be overriden by setting the following in your projects <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package.metadata.vita]
# ...
# Disables extended memory budget
vita_mksfoex_flags = []
# ...
</code></pre>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<p>Stack is allocated on MAIN memory. The stack size for a main thread is 4 KiB.
To change the stack size of your main thread, export the following static variable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[used]
#[export_name = &quot;sceUserMainThreadStackSize&quot;]
pub static SCE_USER_MAIN_THREAD_STACK_SIZE: u32 = 1 * 1024 * 1024; // 1 MiB
<span class="boring">}</span></code></pre></pre>
<p>When creating an new thread, you can set the stack size of it as usual:</p>
<pre><pre class="playground"><code class="language-rust edition2021">pub fn main() {
    std::thread::Builder::new()
        .stack_size(1 * 1024 * 1024) // 1 MiB
        .spawn(move || todo!(&quot;work&quot;))
        .expect(&quot;Unable to spawn thread&quot;)
        .join()
        .expect(&quot;Unable to join thread&quot;);
}</code></pre></pre>
<h2 id="heap"><a class="header" href="#heap">Heap</a></h2>
<p>The default <a href="https://doc.rust-lang.org/stable/std/alloc/struct.System.html">System allocator</a> in Rust will use <a href="https://github.com/vitasdk/newlib/blob/vita/newlib/libc/sys/vita/sbrk.c#L33">newlib heap</a>. This heap pre-allocates a memory block of a maximum heap size and never resizes. All allocation happen within this pre-allocated memory block in MAIN memory.</p>
<p>The default newlib heap size is 128 MiB. You can set a custom heap size by exporting the following static variable:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[used]
#[export_name = &quot;_newlib_heap_size_user&quot;]
pub static _NEWLIB_HEAP_SIZE_USER: u32 = 256 * 1024 * 1024; // 256 MiB
<span class="boring">}</span></code></pre></pre>
<h2 id="considerations-1"><a class="header" href="#considerations-1">Considerations</a></h2>
<p>Besides the newlib heap, if you are linking against native libraries or using syscalls of various modules provided by stubs, they may do custom allocations with <a href="https://docs.vitasdk.org/group__SceSysmemUser.html#ga6f4fd5dc592c7e7a907225196160b597">sceKernelAllocMemBlock</a> syscall.</p>
<p>Some of them may also be using sceLibc heap, which is another heap allocated on MAIN memory. If you experience OOM errors in such cases, you can resize the sceLibc heap size:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[used]
#[export_name = &quot;sceLibcHeapSize&quot;]
pub static SCE_LIBC_HEAP_SIZE: u32 = 10 * 1024 * 1024; // 10 MiB
<span class="boring">}</span></code></pre></pre>
<div class="warning">
<p>Keep in mind that stack, newlib heap and sceLibc heap are all located in MAIN memory, so their sum should not exceed the allowed memory budget.</p>
</div>
<h2 id="manual-allocation"><a class="header" href="#manual-allocation">Manual allocation</a></h2>
<p>In some cases (e.g when implementing a custom rasterizer with framebuffers), you may want to allocate memory outside of the heap or MAIN memory.</p>
<p>The low-level way to allocate memory on Sony PlayStation Vita is by using a <a href="https://docs.vitasdk.org/group__SceSysmemUser.html#ga6f4fd5dc592c7e7a907225196160b597">sceKernelAllocMemBlock</a> syscall</p>
<p>Here is an example of it may be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use vitasdk_sys::*;

pub struct Buffer {
    buf: *mut c_void,
    block_uid: SceUID,
    size: u32,
}

impl Buffer {
    fn new(size: u32) -&gt; Buffer {
        let mut buf: *mut c_void = ::core::ptr::null_mut();

        // The minimal allocation unit is a memory page
        let unit = 0x40000 - 1;
        let size = (size + unit) &amp; !unit;

        let block_uid = unsafe {
            let block_uid: SceUID = sceKernelAllocMemBlock(
                b&quot;display\0&quot;.as_ptr() as *const c_char,
                SCE_KERNEL_MEMBLOCK_TYPE_USER_CDRAM_RW,
                size,
                ::core::ptr::null_mut(),
            );
            sceKernelGetMemBlockBase(block_uid, &amp;mut buf);
            block_uid
        };

        Buffer {
            buf: buf as _,
            size,
            block_uid,
        }
    }
}

impl Drop for Buffer {
    fn drop(&amp;mut self) {
        unsafe {
            sceKernelFreeMemBlock(self.block_uid);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<p>Sony PlayStation Vita has a support for IPv4 stack (IPv6 is not supported). Network API is exposed via usual POSIX socket API by <a href="https://github.com/vitasdk/newlib">newlib</a>.</p>
<p>Most of the existing popular libraries for should already either support Vita target, or it should be fairly trivial to port them by enabling it with <a href="https://doc.rust-lang.org/rust-by-example/attribute/cfg.html">conditional checks</a>, and disabling unsupported parts.</p>
<h2 id="non-blocking-sockets"><a class="header" href="#non-blocking-sockets">Non-blocking sockets</a></h2>
<p>In POSIX the usual way to make a socket non-blocking, or check if it is non-blocking is by using <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl</a> syscall.
Currently this syscall is not implemented in <a href="https://github.com/vitasdk/newlib">newlib</a>.</p>
<p>When porting network libraries for Vita, to change sockets non-blocking flag, or get this flags value, use <code>setsockopt</code> and <code>getsockopt</code> syscalls:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn nonblocking(fd: libc::c_int) -&gt; bool {
    let mut non_block: libc::c_int = 0;
    let mut len: libc::socklen_t = 0;
    unsafe {
        libc::getsockopt(
            fd,
            libc::SOL_SOCKET,
            libc::SO_NONBLOCK,
            &amp;mut nonblock as *mut libc::c_int as _,
            &amp;mut len as _,
        );
    }

    non_block != 0
}

fn set_nonblocking(fd: libc::c_int, non_block: bool) {
    let non_block = non_block as libc::c_int;
    unsafe {
        libc::setsockopt(
            fd,
            libc::SOL_SOCKET,
            libc::SO_NONBLOCK,
            &amp;non_block as *const libc::c_int as _,
            std::mem::size_of::&lt;libc::c_int&gt;() as libc::socklen_t,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="https"><a class="header" href="#https">HTTPS</a></h2>
<p>In rust ecosystem when using TLS you usually can choose between two implementations - OpenSSL and <a href="https://github.com/rustls/rustls">rustls</a>.</p>
<p>Vita does not <strong>natively</strong> provide OpenSSL and instead has it's own API for TLS. But the usual installation of <a href="https://vitasdk.org/">Vita SDK</a> provides OpenSSL implementation which statically be linked to.</p>
<p>So in a nutshell, both choices should work on Vita.</p>
<p>There is an inconvenience with CA certificates though. Usually on a hacked Vita you would have <a href="https://github.com/SKGleba/iTLS-Enso">iTLS-Enso</a> installed for the latest CA certificates. These certificates are only available for the native TLS api. And the native TLS API provided by Vita does not have a way to export the CA certificates themselves.
The certificate file is located on the filesystem on <code>vs0:data/external/cert/CA_LIST.cer</code>, but the <code>vs0</code> partition is not available for the safe applications.</p>
<p>In practice this means the following:</p>
<ul>
<li>
<p>You can use <a href="https://github.com/rustls/rustls">rustls</a> with <a href="https://github.com/rustls/webpki-roots">webpki-roots</a> crate to provide CA certificates. The certificates will be then bundled inside of your binary.</p>
</li>
<li>
<p>Use either <a href="https://github.com/rustls/rustls">rustls</a> with <a href="https://github.com/rustls/rustls-native-certs">rustls-native-certs</a> or <a href="https://github.com/sfackler/rust-native-tls">native-tls</a> crate for OpenSSL implementation. In both the scenarios your application will try to find CA certificated provided by the operating system.</p>
<p>You will have to set a <code>SSL_CERT_FILE</code> environment variable in your code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    std::env::set_var(&quot;SSL_CERT_FILE&quot;, &quot;vs0:data/external/cert/CA_LIST.cer&quot;);
    // ... your code
}</code></pre></pre>
<p>as well as make your application unsafe in order for it to have access to the <code>vs0</code> partition. To do that add the following to your <code>Cargo.toml</code></p>
<pre><code class="language-toml">[package.metadata.vita]
# ...
# This disables safe mode (default -s flag) for reading OpenSSl certs
vita_make_fself_flags = []
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics"><a class="header" href="#graphics">Graphics</a></h1>
<p>There are multiple ways you can approach graphics programming on Vita.</p>
<h1 id="approaches"><a class="header" href="#approaches">Approaches</a></h1>
<h2 id="native"><a class="header" href="#native">Native</a></h2>
<p>You can use the native Vita modules for graphics programming. You can find the documentation for the API in <a href="https://docs.vitasdk.org/group__SceGxmUser.html">Vita SDK docs</a> and the bindings to the syscalls in <a href="https://github.com/vita-rust/vitasdk-sys/">vitasdk-sys</a> crate.</p>
<h2 id="sdl2"><a class="header" href="#sdl2">SDL2</a></h2>
<p>The easiest way to start working with SDL2 in Rust would be using <a href="https://github.com/Rust-SDL2/rust-sdl2">rust-sdl2</a> crate, which fully works on Vita without any additional work.</p>
<p>Keep in mind that graphics API provided by SDL2 is rudimentary and suitable mostly for simple 2D games. If you need something more complicated, you probably want to go the OpenGL route.</p>
<h2 id="opengl-es2"><a class="header" href="#opengl-es2">OpenGL ES2</a></h2>
<p>There exist two homebrew implementations for OpenGL. Keep in mind that probably neither of the solutions supports the full OpenGL ES2 spec, and may be limited by the capabilities of Vita GPU. </p>
<h3 id="vitagl"><a class="header" href="#vitagl">vitaGL</a></h3>
<p><a href="https://github.com/Rinnegatamante/vitaGL">VitaGL</a> provides OpenGL ES2 compatible API by using native GXM API internally and <a href="https://github.com/Rinnegatamante/vitaShaRK">vitaShaRK</a> for shader compilation.</p>
<p>It is possible to use <a href="https://github.com/Rinnegatamante/vitaGL">vitaGL</a> together with <code>SDL2</code> as an abstraction layer for input, but the <code>SDL2</code> library provided by Vita SDK does not support <a href="https://github.com/Rinnegatamante/vitaGL">vitaGL</a>, so for you will have to use this <a href="https://github.com/Northfear/SDL">SDL2 fork</a>.</p>
<h3 id="pvr_psp2"><a class="header" href="#pvr_psp2">PVR_PSP2</a></h3>
<p>TODO <a href="https://github.com/GrapheneCt/PVR_PSP2">PVR_PSP2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running"><a class="header" href="#running">Running</a></h1>
<p>After you have built a <code>vpk</code> file, you have two options to run it:</p>
<ul>
<li>On a <a href="https://henkaku.xyz/">hacked</a> Sony PlayStation Vita device</li>
<li>On a <a href="https://vita3k.org/">Vita3K</a> emulator</li>
</ul>
<h2 id="running-on-the-real-hardware"><a class="header" href="#running-on-the-real-hardware">Running on the real hardware</a></h2>
<p>If you are going to test your application on physical hardware you first need to deliver and install your <code>vpk</code> on your Vita.</p>
<p>This can be either:</p>
<ul>
<li>Done manually with <a href="https://github.com/TheOfficialFloW/VitaShell">VitaShell</a></li>
<li>Automated using <a href="https://github.com/vita-rust/cargo-vita">cargo-vita</a>. This will require you to have a number of additional tools installed (see <a href="./getting_started.html#optional-tools">Getting Started</a>).</li>
</ul>
<h2 id="running-on-the-emulator"><a class="header" href="#running-on-the-emulator">Running on the emulator</a></h2>
<p>After installing the emulator and setting it up correctly, installing and running your <code>vpk</code> is as simple as:</p>
<pre><code class="language-sh"># Optionally remove the previous vpk with your title_id
vita3k -d RUST00001
# Installs the vpk and runs it
vita3k ./target/armv7-sony-vita-newlibeabihf/release/your_app.vpk

</code></pre>
<p>Keep in mind that an emulator is not a real device, and some programs that would work on real hardware won't work in an emulator, and vice versa.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsupported-features"><a class="header" href="#unsupported-features">Unsupported features</a></h1>
<p>Some std features are not supported on Vita target:</p>
<ul>
<li><code>std::process</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
